"use strict"

var bitcoin = require('bitcoinjs-lib')
var errors = require('./errors')
var HttpUtility = require('./http-utility')

module.exports = {
    Client: Client,
    Xpub: Xpub,
    Xprv: Xprv,
    errors: errors
}

function isString(o) {
    if (typeof o === "string") {
        return true
    }
    return typeof o === "object" && o !== null && o.constructor === String
}

/**
 * Creates a Chain Enterprise API client.
 * @constructor
 */
function Client(c) {
    this.auth = {
        user: c.tokenID || c.tokenId,
        pass: c.tokenSecret
    }

    if (!c.url) {
        throw new Error('missing api url')
    }
    if (!c.apiVersion) {
        c.apiVersion = 'v3'
    }
    if (!c.timeout) {
        c.timeout = 10000; // 10 seconds
    }

    var baseurl = c.url + '/' + c.apiVersion
    this.api = new HttpUtility({
        url: baseurl,
        auth: this.auth,
        timeout: c.timeout
    })

    this.certChain = c.certChain
    this.certKey = c.certKey
    this.keyStore = new KeyStore()
}

Client.prototype.createIssuerNode = function (projectID, opts, cb) {
    this.api.post('/projects/' + projectID + '/issuer-nodes', opts, cb)
}

Client.prototype.getIssuerNode = function (issuerNodeID, cb) {
    this.api.get('/issuer-nodes/' + issuerNodeID, cb)
}

Client.prototype.updateIssuerNode = function (issuerNodeID, opts, cb) {
    this.api.put('/issuer-nodes/' + issuerNodeID, opts, cb)
}

Client.prototype.deleteIssuerNode = function (issuerNodeID, cb) {
    this.api.delete('/issuer-nodes/' + issuerNodeID, cb)
}

Client.prototype.listIssuerNodeActivity = function (issuerNodeID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/issuer-nodes/' + issuerNodeID + '/activity',
        headers: headers
    }, cb)
}
Client.prototype.getIssuerNodeActivity = Client.prototype.listIssuerNodeActivity // DEPRECATED

Client.prototype.listAssets = function (issuerNodeID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/issuer-nodes/' + issuerNodeID + '/assets',
        headers: headers
    }, cb)
}
Client.prototype.getAssets = Client.prototype.listAssets // DEPRECATED

/**
 * Creates an asset on the given issuer node.
 * @param {string} issuerNodeID
 * @param {Object} opts
 * @param {string} opts.label - a human-readable label for this asset
 * @param {Object} opts.definition - the asset definition, as keys/values
 *
 */
Client.prototype.createAsset = function (issuerNodeID, opts, cb) {
    // For backward compatibility
    if (isString(opts)) {
        opts = {
            label: opts
        }
    }
    this.api.post('/issuer-nodes/' + issuerNodeID + '/assets', opts, cb)
}

Client.prototype.getAsset = function (assetID, cb) {
    this.api.get('/assets/' + assetID, cb)
}

Client.prototype.updateAsset = function (assetID, opts, cb) {
    this.api.put('/assets/' + assetID, opts, cb)
}

Client.prototype.deleteAsset = function (assetID, cb) {
    this.api.delete('/assets/' + assetID, cb)
}

Client.prototype.listAssetActivity = function (assetID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/assets/' + assetID + '/activity',
        headers: headers
    }, cb)
}
Client.prototype.getAssetActivity = Client.prototype.listAssetActivity // DEPRECATED

Client.prototype.listManagerNodes = function (projectID, cb) {
    this.api.get('/projects/' + projectID + '/manager-nodes', cb)
}
Client.prototype.getManagerNodes = Client.prototype.listManagerNodes // DEPRECATED

Client.prototype.createManagerNode = function (projectID, opts, cb) {
    this.api.post('/projects/' + projectID + '/manager-nodes', opts, cb)
}

Client.prototype.getManagerNode = function (managerNodeID, cb) {
    this.api.get('/manager-nodes/' + managerNodeID, cb)
}

Client.prototype.updateManagerNode = function (managerNodeID, opts, cb) {
    this.api.put('/manager-nodes/' + managerNodeID, opts, cb)
}

Client.prototype.deleteManagerNode = function (managerNodeID, cb) {
    this.api.delete('/manager-nodes/' + managerNodeID, cb)
}

Client.prototype.listManagerNodeBalances = function (managerNodeID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/manager-nodes/' + managerNodeID + '/balance',
        headers: headers
    }, cb)
}
Client.prototype.getManagerNodeBalances = Client.prototype.listManagerNodeBalances // DEPRECATED

Client.prototype.listManagerNodeActivity = function (managerNodeID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/manager-nodes/' + managerNodeID + '/activity',
        headers: headers
    }, cb)
}
Client.prototype.getManagerNodeActivity = Client.prototype.listManagerNodeActivity // DEPRECATED

Client.prototype.getManagerNodeTransaction = function (managerNodeID, transactionID, cb) {
    this.api.get('/manager-nodes/' + managerNodeID + '/transactions/' + transactionID, cb)
}

Client.prototype.listAccounts = function (managerNodeID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/manager-nodes/' + managerNodeID + '/accounts',
        headers: headers
    }, cb)
}
Client.prototype.getAccounts = Client.prototype.listAccounts // DEPRECATED

/**
 * Creates an account on the given manager node.
 * @param {string} managerNodeID
 * @param {Object} opts
 * @param {string} opts.label - a human-readable label for this account
 * @param {string[]} opts.keys - an array of xpubs, for manager nodes which
 *                  require variable keys. The number of keys provided by the
 *                  account must be the same as the number of variable keys
 *                  required by the manager node.
 * @param {function} cb - result callback
 */
Client.prototype.createAccount = function (managerNodeID, opts, cb) {
    // For backward compatibility
    if (isString(opts)) {
        opts = {
            label: opts
        }
    }
    this.api.post('/manager-nodes/' + managerNodeID + '/accounts', opts, cb)
}

Client.prototype.getAccount = function (accountID, cb) {
    this.api.get('/accounts/' + accountID, cb)
}

Client.prototype.updateAccount = function (accountID, opts, cb) {
    this.api.put('/accounts/' + accountID, opts, cb)
}

Client.prototype.deleteAccount = function (accountID, cb) {
    this.api.delete('/accounts/' + accountID, cb)
}

Client.prototype.listAccountBalances = function (accountID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/accounts/' + accountID + '/balance',
        headers: headers
    }, cb)
}
Client.prototype.getAccountBalances = Client.prototype.listAccountBalances // DEPRECATED

Client.prototype.listAccountActivity = function (accountID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/accounts/' + accountID + '/activity',
        headers: headers
    }, cb)
}
Client.prototype.getAccountActivity = Client.prototype.listAccountActivity // DEPRECATED


Client.prototype.createAddress = function (accountID, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var self = this
    self.api.post('/accounts/' + accountID + '/addresses', opts, cb)
}

/**
 *
 *  TRANSACT
 *
 */

/**
 * Signs a set of transactions using the local key store.
 * @param {Array} transactions - A list of transactions, returned by
 *        Client#buildTransactionBatch()
 */
Client.prototype.signTransactionBatch = function (transactions) {
    for (var h = 0; h < transactions.length; h++) {
        var transaction = transactions[h]
        for (var i = 0; i < transaction.inputs.length; i++) {
            var inp = transaction.inputs[i]
            var sigs = inp.signatures

            for (var c = 0; c < sigs.length; c++) {
                var s = sigs[c],
                    key = this.keyStore.get(s.xpub)

                // sigs contains entries for multiple signers,
                // so we need to ignore any that we don't recognize
                // or are unable to sign
                if (!(key && key.canSign)) {
                    continue
                }

                var xprv = key.xprv(s.xprv_encrypted),
                    path = s.derivation_path
                for (var j = 0; j < path.length; j++) {
                    xprv = xprv.derive(path[j])
                }

                var sigData = new Buffer(inp.signature_data, "hex")
                var sig = xprv.privKey.sign(sigData).toScriptSignature(bitcoin.Transaction.SIGHASH_ALL)
                s.signature = sig.toString('hex')
            }
        }
    }
}

Client.prototype.signTransaction = function (transaction) {
    this.signTransactionBatch([transaction])
}

/**
 * Finalizes a set of transactions using the Chain Enterprise API.
 * @param {Array} transactions - A list of transactions, created by
 *        Client#buildTransactionBatch and signed by
 *        Client#signTransactionBatch
 */
Client.prototype.submitTransactionBatch = function (transactions, cb) {
    this.api.post('/transact/submit', {
        transactions: transactions
    }, function (err, results, resp) {
        if (err) {
            return cb(err)
        }

        var requestID = resp.headers['chain-request-id']
        for (var i = 0; i < results.length; i++) {
            var res = results[i]
            if (errors.isBatchError(res)) {
                res.requestID = requestID
            }
        }

        cb(null, results)
    })
}

Client.prototype.submitTransaction = function (transaction, cb) {
    this.submitTransactionBatch([transaction], function (err, results) {
        if (err) {
            return cb(err)
        }

        var res = results[0]

        // If the result item is an error, translate it to an error object and
        // return it as the callback error.
        if (errors.isBatchError(res)) {
            cb(errors.newApiError(res))
        } else {
            cb(null, res)
        }
    })
}

Client.prototype.issue = function (assetID, outputs, cb) {
    var self = this
    self.buildIssuance(assetID, outputs, function (err, transaction) {
        if (err) {
            return cb(err)
        }

        try {
            self.signTransaction(transaction)
        } catch (err) {
            return cb(err)
        }

        self.submitTransaction(transaction, cb)
    })
}

Client.prototype.buildIssuance = function (assetID, outputs, cb) {
    this.api.post("/assets/" + assetID + "/issue", outputs, function (err, resp) {
        if (err) {
            return cb(err)
        }
        cb(null, resp.template)
    })
}

Client.prototype.transferBatch = function (txRequests, cb) {
    var self = this
    self.buildTransactionBatch(txRequests, function (err, transactions) {
        if (err) {
            return cb(err)
        }

        // Filter out bad build results.
        var validTxs = []
        for (var i = 0; i < transactions.length; i++) {
            var t = transactions[i]
            if (!errors.isBatchError(t)) {
                validTxs.push(t)
            }
        }

        try {
            self.signTransactionBatch(validTxs)
        } catch (err) {
            return cb(err)
        }

        self.submitTransactionBatch(validTxs, function (err, results) {
            if (err) {
                return cb(err)
            }

            // Reinsert errors entries from the build step
            for (var i = 0; i < transactions.length; i++) {
                var t = transactions[i]
                if (errors.isBatchError(t)) {
                    results.splice(i, 0, t)
                }
            }

            cb(null, results)
        })
    })
}

Client.prototype.transfer = function (txRequest, cb) {
    var self = this
    self.buildTransaction(txRequest, function (err, transaction) {
        if (err) {
            return cb(err)
        }

        try {
            self.signTransaction(transaction)
        } catch (err) {
            return cb(err)
        }

        self.submitTransaction(transaction, cb)
    })
}

Client.prototype.buildTransactionBatch = function (txRequests, cb) {
    this.api.post("/transact/build", txRequests, function (err, results, resp) {
        if (err) {
            return cb(err)
        }

        var transactions = [],
            requestID = resp.headers['chain-request-id']

        for (var i = 0; i < results.length; i++) {
            var res = results[i]
            if (errors.isBatchError(res)) {
                res.requestID = requestID
                transactions[i] = res
            } else {
                transactions[i] = res.template
            }
        }

        cb(null, transactions)
    })
}

Client.prototype.buildTransaction = function (txRequest, cb) {
    this.buildTransactionBatch([txRequest], function (err, results) {
        if (err) {
            return cb(err)
        }

        var res = results[0]

        // If the result item is an error, translate it to an error object and
        // return it as the callback error.
        if (errors.isBatchError(res)) {
            cb(errors.newApiError(res))
        } else {
            cb(null, res)
        }
    })
}

/**
 * Returns a list of confirmed blocks recorded by the auditor node.
 * @param {object} [opts]
 * @param {string} [opts.after] - a pagination cursor
 * @param {function} - result callback
 */
Client.prototype.listAuditorNodeBlocks = function (opts, cb) {
    if (typeof opts === 'function') {
        cb = opts
        opts = {}
    }

    var headers = {}
    if (opts.after) {
        headers['range-after'] = opts.after
    }

    this.api.makeRequest({
        method: 'GET',
        path: '/auditor/blocks',
        headers: headers
    }, cb)
}

/**
 * For the given block, returns the block header and a list of IDs of
 * transactions contained in the block.
 * @param {string} blockID - the ID of the block
 * @param {function} - result callback
 */
Client.prototype.getAuditorNodeBlockSummary = function (blockID, cb) {
    this.api.get('/auditor/blocks/' + blockID + '/summary', cb)
}

/**
 * Returns a transaction recorded by the auditor node.
 * @param {string} transactionID - the ID of the transaction
 * @param {function} - result callback
 */
Client.prototype.getAuditorNodeTransaction = function (transactionID, cb) {
    this.api.get('/auditor/transactions/' + transactionID, cb)
}

/**
 * Returns an asset whose issuance was recorded by the auditor node.
 * @param {string} assetID - the ID of the transaction
 * @param {function} - result callback
 */
Client.prototype.getAuditorNodeAsset = function (assetID, cb) {
    this.api.get('/auditor/assets/' + assetID, cb)
}

/**
 *
 *  KEYS
 *
 */

// A keyStore is a set of key objects.
// A key object may or may not be able to produce
// an xprv, and it may or may not need to be given
// the encrypted xprv to do so.
function KeyStore() {
    this.data = {}
}

KeyStore.prototype.add = function (k) {
    this.data[k.xpub] = k
}

// Note: this dictionary is keyed on the xpub.
// This is the bitcoin-style hash160 function
// (RIPEMD(SHA256(x))) of the base58 encoding
// of the serialized xpub data.
KeyStore.prototype.get = function (xpub) {
    return this.data[xpub]
}

// Xprv takes a base58-encoded xprv and a boolean
// flag indicating whether it can be used to receive funds.
function Xprv(xprv, canRecv) {
    this.xprvObj = bitcoin.HDNode.fromBase58(xprv)
    this.xpub = this.xprvObj.neutered()
    this.canReceive = canRecv
    this.canSign = true
}

Xprv.prototype.xprv = function () {
    return this.xprvObj
}

// Xpub takes a base58-encoded xpub and a boolean
// flag indicating whether it can be used to receive funds.
function Xpub(xpub, canRecv) {
    this.xpub = bitcoin.HDNode.fromBase58(xpub)
    this.canReceive = canRecv
    this.canSign = false
}

Xpub.prototype.xprv = function () {
    throw new Error("xpub-only key cannot return xprv")
}
Xpub.prototype.xpriv = Xpub.prototype.xprv; // deprecated
